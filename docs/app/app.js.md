---
order: 1
---

wq/app.js
======

[wq/app.js]

**wq/app.js** is a [wq.app] module that provides a configuration-driven JavaScript application controller to facilitate the creation of complete mobile web apps for viewing and submitting field data.   wq/app.js is primarily intended for use as a client for [wq.db]'s [app.py], but can be used with any REST service with the same [URL structure].

## Overview

wq/app.js is the highest-level wq.app module, and brings together a number of lower-level modules and wq conventions into an integrated API.  As a primarily configuration-driven module, wq/app.js is relatively easy to use, but enforces a number of constraints on the design of your project.  In particular, it works best with [wq.db.rest] or a compatible REST service.  Depending on your project needs, it may be better to forego wq/app.js and directly utilize the underlying APIs in [wq/store.js] and [wq/pages.js].  The documentation for those modules is also useful as a background to this module.

The specific concepts leveraged by wq/app.js include:

 * A specific [URL structure] that is observed by both the application itself and its REST API.
 * A client-side URL router and page renderer (provided by [wq/pages.js]) that can fall back to server-rendered pages via [shared client/server templates].
 * A model-driven, `localStorage`-backed cache of REST API responses (provided by [wq/store.js]).
 *  A [wq configuration object] generated by the URL router on the server, that describes the available routes (and underlying models).
 * An optional [authentication] endpoint provided by the REST API, including CSRF tokens to prevent cross-site attacks.

## API

`wq/app.js` is typically imported via [AMD] as `app`, though any local variable name can be used.

```javascript
// myapp.js
define(['wq/app', ...], function(app, ...) {
    app.init(...);
});
```

The app module provides the following methods and properties.

### `app.init()`
In a simple project, the only required usage of wq/app.js is to initialize it:

```javascript
app.init(config, templates, [baseurl], [svcurl]);
```

`app.init()` accepts up to four arguments:

name | purpose
-----|---------
`config` | a wq/app.js configuration object (described below)
`templates` | a collection of [Mustache templates] for use in [client-side rendering]
`baseurl` | (optional) path used to prefix application URLs to help with route matching in [wq/pages.js].  `baseurl` should be set to the base url of your application (without the trailing `/`) if your application is not running at the root of your domain.
`svcurl` | (optional) path or fully-qualified URL used to prefix REST API requests in [wq/store.js].  It should only need to be set be if your REST service is not running at the same base url as your application.  For best results, the application and the REST service should be running at the same URL (see "[My website is its own REST API]").

`app.init()` internally calls [pages.register()] for each page in the `pages` configuration section.  The callbacks sent to `pages.register()` are simple wrappers around `app.go()`.

### `<form>` Handler

`app.init()` registers a custom submit handler that takes normal form POSTs and converts them to REST API calls.  To avoid interaction with jQuery Mobile's own AJAX form handler, it is recommended to set `data-ajax="false"` on all forms using this functionality.  For model-backed list pages, these forms would normally be placed in `[page]_edit.html` templates and accessed via `/[page_url]/new` `/[page_url]/[id]/edit` .

```xml
<form method="post" action="/items" data-ajax="false">
```

By default wq/app.js' form handler is applied to every form in the website.  This functionality can be disabled on a per-form basis by setting `data-json=false` on the form tag:

```xml
<form method="post" action="/custom" data-json="false">
```

To disable both jQuery Mobile's AJAX form handler and wq/app.js' AJAX+JSON form handlers, specify both properties:

```xml
<form method="post" action="/custom" data-json="false" data-ajax="false">
```

The form handler can automatically display any error messages returned from the REST API, both per-field errors and general validation errors.  This functionality can be leveraged by placing `<span>` or `<p>` tags next to the fields and near the submit button.  The tags should have two classes: `error` and `[page]-[field]-errors`, where `page` is the name of the of the wq page config and `field` is the name of the form field.

When working with list pages, the same template (`[page]_edit.html`) is used for both new and existing items.  The presence of an `id` attribute in the context can be used to distinguish between the two use cases.  In addition, a number of other useful context variables are provided to assist with rendering e.g. `<select>` menus for foreign keys.  See the [template context] documentation for more details.

#### Example

```xml
<!-- item_edit.html -->

<!-- Different action/method depending on whether this is a new or existing item -->
<form action="/items/{{id}}" data-ajax="false"
      method="{{#id}}put{{/id}}{{^id}}post{{/id}}">
  <ul>
  
    <li>
      <label for="item-name">Name</label>
      <input name="name" value="{{name}}" id="item-name">
      
      <!-- Placeholder for "name" errors -->
      <span class="error item-name-errors"></span>
    </li>
    
    <li>
      <label for="item-date">Date</label>
      <input name="date" type="date" value="{{date}}" id="item-date">
      
      <!-- Placeholder for "date" errors -->
      <span class="error item-date-errors"></span>
    </li>
    
    <li>
      <!-- Placeholder for general errors -->
      <span class="error item-errors"></span>
      
      <button type="submit">Save Changes</button>
    </li>
  </ul>
</form>
```

### `app.go()`

`app.go()` is called automatically whenever the URL changes, e.g. in response to the user clicking on a link.  However, there are rare cases where you may need to call it directly.  app.go() is essentially a wrapper for [pages.go()] that automatically generates the appropriate [template context] for list, detail, edit, and simple views.

```javascript
app.go(page, ui, params, [itemid], [edit], [url], [context])
```

`app.go()` accepts up to seven arguments:

name | purpose
-----|---------
`name` | The name of a page listed in `config.pages` (described below)
`ui` | A jQuery Mobile [ui object] describing options for an event
`params` | Any additional URL parameters (`?name1=value1&name2=value2` etc.)
`itemid` | (optional) The id for an individual item in a list (triggers a detail view instead of a list view)
`edit` | (optional) Boolean, if true triggers an edit view instead of a detail view
`url` | (optional) URL to display for the rendered page.  Usually this is automatically computed.
`context` | (optional) Initial template context variable (will be merged with the automatically generated context).

The default template contexts for detail and edit views contain a number of context variables that assist in looking up and displaying information from related models, e.g. a list of potential values for a foreign key.  These lookup contexts can be customized by overriding hooks (see Advanced Customization, below).

### `app.sync()`

Triggers a background sync of pending outbox items in [wq/store.js].  Called automatically at regular intervals if `backgroundSync` is enabled (see Configuration below).  Outbox items causing server errors will be excluded from further syncs after 3 sync attempts (This threshold can be controlled via [wq/store.js]' `maxRetries` option.)  To try re-sending all unsaved items, including those causing server errors (for example in response to a user-initiated sync), call `app.sync(true)` instead of `app.sync()`.

### `app.user`

If the application supports authentication and the user is logged in, `app.user` will be set with information about the current user provided by the server.  This information will also be available in the [template context], e.g. `{{is_authenticated}}{{user.username}}{{/is_authenticated}}`.

### `app.config`, `app.wq_config`
A copy of the wq/app.js configuration object (see below) and the [wq configuration object], respectively.  Initially `app.config.pages` and `app.wq_config.pages` are the same, but after logging in, `app.wq_config` is overwritten with an updated wq configuration object with permissions information specific to the logged-in user.  `app.config` is made available in the [template context] as `{{app_config}}`, while `app.wq_config` is provided as `{{wq_config}}`.

### `app.native`

Whether the application is running under [PhoneGap] / [Cordova] or as a web app (`true` and `false` respectively).  Available in the [template context] as `{{native}}`.

## Configuration

The wq/app.js configuration object has one or more of the following properties.

```javascript
{
    // Scalar options
    'debug': true, // or 3
    'backgroundSync': true, // or 30
    
    // Nested option blocks
    'pages': { /* ... */ }, // copied from wq config
    'defaults': { /* ... */ },
    'transitions': { /* ... */ },
    'store': { /* ... */ },
    
    // One or more hooks, see "Hooks" below
    'hookName': function() {}
}
```

### Scalar Options

The `debug` option enables console logging in wq/app.js, [wq/store.js] and [wq/pages.js].  If specified as a number, `debug` will set the verbosity level in wq/store.js.

The `backgroundSync` option tells wq/app.js not to make the user wait for forms to be submitted to the server, and instead to handle all wq/store.js syncing in the background.  If specified as a number, `backgroundSync` will set the number of seconds between sync attempts (default 30).  `backgroundSync` can be overridden on a per-form basis by setting `<form data-background-sync=[value]>`.

### `pages`: URL routes

The `pages` configuration section is typically copied from the [wq configuration object] generated by the REST service and describes the URL routes in the application.  The full list of options is described in the documentation for the [wq configuration object].

> **Note**: If you need to customize an option in the server generated `pages`, you should specify it when calling [app.router.register_model] in [wq.db.rest] rather than overriding the `pages` section in your `config.js`.  This ensures that the client and the server are on the same "page".

### `defaults`: Template Context Variables

The `defaults` configuration section is used to set default values that will be available in every [template rendering context].  The keys are the name of the context variables to use, and the values can be simple strings or functions.  For example, to define variable `{{year}}` that is available in every template, you could do the following:

```javascript
config.defaults = {
    'year': function() {
        return new Date().getFullYear();
    }
};
```

Note that setting a context variable in JavaScript will have no effect for templates rendered by the server.  To achieve consistent template rendering with wq.db, you can use Django's [template context processors].  An equivalent context processor for the above would be:

```python
# myapp/context_processors.py
from datetime import date
def year(request):
    return {
        'year': date.today().year
    }
```

### `transitions`: Page Transitions

Configuration for jQuery Mobile's built in [page transitions].  Where applicable, this information is mapped to jQuery Mobile's built-in configuration options.

 Name | Usage
------|-------
`default` | A shortcut for [$.mobile.defaultPageTransition].  Often set to `slide`.
`dialog` | A shortcut for [$.mobile.defaultDialogTransition].
`save` | Sets the default transition to use when moving from an edit view back to a detail view after a save.  This is often set to `flip`.
`maxwidth` | A shortcut for [$.mobile.maxTransitionWidth].  Defaults to 800 (note that vanilla jQuery Mobile defaults to false),

### `store`: wq/store.js configuration

Configuration options for [wq/store.js].  These options will be passed on as the third argument to `ds.init()`.  See the documentation for [wq/store.js] for the complete list of options.

### Creating a Configuration Module

The configuration object can be defined as a variable in the same file as the call to `app.init()`.  However, the conventional approach is to create a separate AMD module `js/myapp/config.js` that depends on the server-created wq config and then adds the additional attributes:

```javascript
define(['db/config', function(config) {
// config.pages already exists on server-generated wq config

config.defaults = {
// Configure default template context variables
};
config.transitions = {
// Configure default jQuery Mobile page transitions
}
config.store = {
// Configure wq/store.js
}
return config;
});
```

If you are not utilizing the wq.db-generated configuration, you can define the entire configuration object in config.js:

```javascript
define({
    'pages': { /* ... */ },
    'defaults': { /* ... */ },
    'transitions': { /* ... */ },
    'store': { /* ... */ }
});
```

### Inlining Templates
The `templates` can be created as regular Mustache HTML files and then inlined into a JavaScript object through the [collectjson] step in the [wq build process].  The resulting object should be of the form:

```javascript
{
     '[modelname]_list': "<html>...</html>",
     '[modelname]_detail': "<html>...</html>",
     '[modelname]_edit': "<html>...</html>",
     // so on for each model...
     
     '[staticpage]': "<html>...</html>",
     'partials': {
          'head': "..."
     }
}
```
By convention, this object is typically wrapped in an AMD `define()` and placed in the file `js/myapp/templates.js`.

### Putting it all Together

`app.init()` should typically be called immediately when the JavaScript loads.  Assuming `template.js` and `config.js` are created as above, this can be accomplished by creating a main module for your application:

```javascript
// js/myapp.js
requirejs.config({
    'baseUrl': 'lib', // wq and third party libs
    'paths': {
        'myapp': '../myapp',
        'db': '../../'
    }
});
requirejs(['myapp/main']);

// js/myapp/main.js
require(['wq/app', './config', './templates'],
function(app, config, templates) {
   app.init(config, templates);
});
```

And then configuring RequireJS to load it in your `index.html`:
```xml
<script src="js/lib/require.js" data-main="js/myapp.js"></script>
```

If you are utilizing both wq.app and wq.db in your project, you may find it useful to leverage the [Django wq template] which will set up the above project layout for you.

## Advanced Customization

wq/app.js provides a number of events and hooks for additional customization.

### Events

#### `login`

Callbacks registered with the `login` event will be called whenever the user logs in (as well as at the start of the application if the user is already logged in).

```javascript
$('body').on('login', function(){
    /*...*/
});
```

#### `logout`

Callbacks registered with the `logout` event will be called whenever the user logs out.

```javascript
$('body').on('logout', function() {
    /*...*/
});
```

### Hooks

These hooks can be customized by adding additional options to the wq/app.js config object.

#### `postsave(item, result, conf)`

If background sync is disabled, `postsave()` is called after a successful form post with the `item` and `result` from [ds.save()], as well as the configuration for the page that initialized the save.  The default implementation of `postsave()` navigates to the detail view of the newly saved item (unless the [page configuration] has a `postsave` property).  `postsave()` is meant to be overridden in cases where `conf.postsave` does not provide enough flexibility.

```javascript
config.postsave = function(item, result, conf) {
    /*...*/
}
app.init(config, templates)
```

#### `saveerror(item, reason, conf)`

If background sync is disabled, `saveerror()` is called when [ds.save()] fails, with the `item` from ds.save(), the reason for the failure, and the configuration for the page that initiated the save.  The `reason` will be one of the constants `app.OFFLINE`, `app.FAILURE`, or `app.ERROR`.  `app.FAILURE` usually indicates a server 500 failure, while `app.ERROR` usually indicates a 400 validation error.

```javascript
config.saveerror = function(item, reason, conf) {
    if (reason == app.OFFLINE)
        alert("You are currently working offline.  Your record is in the outbox");
}
app.init(config, templates);
```

#### `postsubmit(item, conf)`

If background sync is enabled, `postsubmit()` is called after a form is "submitted" with the newly saved outbox item and the configuration for the page that initiated the save.  Unlike `postsave()`, no server result is given, since it will not be known until the next `app.sync()`.  A typical use for `postsubmit()` is to trigger navigation to another screen (since `postsave()` is not triggered if background sync is enabled).

#### `presync()`
Triggered at the beginning of `app.sync()`.  Useful for debugging.

#### `postsync(result)`

Triggered after an `app.sync()`, with the result from `ds.sendAll()` in [wq/store.js].  Useful for alerting the user of persistent sync issues.

#### `parentFilters`

`parentFilters` is a set of hooks to customize the options listed for foreign keys in `edit` views.  (The default is to list all available items for each foreign key.)  `parentFilters` is a mapping of field names to functions that accept the name of the referenced model, the name of the model being edited, and a copy of the context variable.  The functions should return a filter object compatible with [ds.filter()].

```javascript
// config.pages = {'parent': {...}, 'child': {..., 'parents': ['parent']}}
// config.parentFilters = {}
config.parentFilters.parent_id = function(parent_page, page, context) {
    if (context.id) {
        // Previously saved items can reference all parents
        return {};
    } else {
        // new items can only reference active parents
        return {'active': true};
    }
}
app.init(config, templates);
```

#### `attachmentTypes`

`attachmentTypes` is a relatively complex set of hooks for working with the context variables that are automatically generated in edit views for models with "attachments", i.e. models that incorporate one or more of [wq.db]'s [design patterns].  They are grouped by the name of the attachment model (e.g. `annotation`, `identifier`).  The [default implementation] should give a sense of the overall options available, which are also described here.

An `attachmentTypes` section on the wq/app.js configuration object will be merged with the default options (unlike the other hook configurations, which replace the default implementations entirely).

name | purpose
-----|---------
`predicate` | Name of the property on the page configuration that indicates this attachment is applicable
`type` | Name of the "type" model corresponding to this attachment, if any (e.g. each `annotation` has a `type_id` which references `annotationtype`)
`typeColumn` | The name of the foreign key field pointing to the type model (if not `type_id`).
`getTypeFilter(page, context)` | Should return a [ds.filter()]-compatible filter to run on the type list when generating default attachment sets for new items.
`getDefaults(type, context)` | Should return a set of context variables to add for a given type when generating default attachment lists for new items.
`getChoiceList(type, context)` | Should return the name of the model to use when generating a list of options for a `relationship` or `inverserelationship` (the default is to use the `to_type` or `from_type` field on the `relationshiptype`). 
`getChoiceListFilter(type, context)` | Should return the name of a [ds.filter()]-compatible filter to run on the list of options for a `relationship` or `inverserelationship`.

```javascript
// config.pages = {'mymodel': {..., 'annotated': true}}
// config.attachmentTypes = {'annotation': {}}
config.attachmentTypes.annotation.getTypeFilter = function(page, context) {
    var filter = {'for': page};
    
    // New models only have "Notes" type annotations
    if (page == 'mymodel')
        filter['name'] = "Notes";
        
    return filter;
);
app.init(config, templates)
```

[wq/app.js]: https://github.com/wq/wq.app/blob/master/js/wq/app.js
[wq.app]: http://wq.io/wq.app
[wq.db]: http://wq.io/wq.db
[wq/store.js]: http://wq.io/docs/store-js
[wq/pages.js]: http://wq.io/docs/pages-js
[app.py]: http://wq.io/docs/app.py
[URL structure]: http://wq.io/docs/url-structure
[shared client/server templates]: http://wq.io/docs/templates
[authentication]: http://wq.io/docs/auth
[AMD]: http://wq.io/docs/amd
[app.router.register_model]: http://wq.io/docs/app.py
[wq.db.rest]: http://wq.io/docs/about-rest
[wq configuration object]: http://wq.io/docs/config
[My website is its own REST API]: http://wq.io/docs/website-rest-api
[pages.register()]: http://wq.io/docs/pages-js
[pages.go()]: http://wq.io/docs/pages-js
[template context]: http://wq.io/docs/templates
[ui object]: http://api.jquerymobile.com/pagecontainer/
[PhoneGap]: http://phonegap.com
[Cordova]: http://cordova.io
[client-side rendering]: http://wq.io/docs/web-app
[template rendering context]: http://wq.io/templates
[template context processors]: https://docs.djangoproject.com/en/1.6/ref/templates/api/#subclassing-context-requestcontext
[page transitions]: http://view.jquerymobile.com/1.3.2/dist/demos/widgets/transitions/
[$.mobile.defaultPageTransition]: http://view.jquerymobile.com/1.3.2/dist/demos/widgets/transitions/#Globalconfiguration
[$.mobile.defaultDialogTransition]: http://view.jquerymobile.com/1.3.2/dist/demos/widgets/transitions/#Globalconfiguration
[$.mobile.maxTransitionWidth]: http://view.jquerymobile.com/1.3.2/dist/demos/widgets/transitions/#Maxwidthfortransitions
[Mustache templates]: http://wq.io/docs/templates
[collectjson]: http://wq.io/docs/collectjson
[wq build process]: http://wq.io/docs/build
[Django wq template]: https://github.com/wq/django-wq-template
[ds.save()]: http://wq.io/docs/store-js
[page configuration]: http://wq.io/docs/config
[design patterns]: http://wq.io/docs/about-patterns
[default implementation]: https://github.com/wq/wq.app/blob/master/js/wq/app.js#L262-L338
[ds.filter()]: http://wq.io/docs/store-js
